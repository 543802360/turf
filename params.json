{"name":"turf","tagline":"a node.js library for performing gis operations","body":"turf\r\n======\r\n![turf](https://raw.github.com/morganherlocker/turf/master/img/turf.png)\r\n\r\n***a node.js library for performing geospatial operations with geojson***\r\n\r\nAll features are written in a functional manner with no side effects. In nearly all cases, they accept objects created by the point, linestring, polygon, and featurecollection functions, but these are simply for convenience. Any valid geojson Feature of FeatureCollection will do.\r\n\r\n- - -\r\n\r\n##Installation\r\n\r\n```bash\r\nnpm install turf\r\n```\r\n\r\nTurf can also be run in a browser. To use it, download the [minified file](https://raw.github.com/morganherlocker/turf/master/turf.min.js), and include it in a script tag.\r\n\r\n```html\r\n<script src=\"turf.min.js\"></script> \r\n```\r\n\r\nIt can also be installed using bower:\r\n\r\n```bash\r\nbower install turf\r\n```\r\n\r\n- - -\r\n\r\n##Features\r\n\r\n####geometry\r\n- [load](#load)\r\n- [save](#save)\r\n- [point](#point)\r\n- [linestring](#linestring)\r\n- [polygon](#polygon)\r\n- [featurecollection](#featurecollection)\r\n\r\n####joins\r\n- [inside](#inside)\r\n- [tag](#tag)\r\n\r\n####data\r\n- [remove](#remove)\r\n- [filter](#filter)\r\n- [sample](#sample)\r\n\r\n####measurement\r\n- [distance](#distance)\r\n- [nearest](#nearest)\r\n- [bboxPolygon](#bboxPolygon)\r\n- [envelope](#envelope)\r\n- [extent](#extent)\r\n- [square](#square)\r\n- [size](#size)\r\n- [center](#center)\r\n- [centroid](#centroid)\r\n- [midpoint](#midpoint)\r\n\r\n####interpolation\r\n- [tin](#tin)\r\n- [grid](#grid)\r\n- [planepoint](#planepoint)\r\n- [contour](#contour)\r\n\r\n####classification\r\n- [quantile](#quantile)\r\n- [jenks](#jenks)\r\n- [reclass](#reclass)\r\n\r\n####aggregation\r\n- [average](#average)\r\n- [median](#median)\r\n- [sum](#sum)\r\n- [min](#min)\r\n- [max](#max)\r\n- [count](#count)\r\n- [deviation](#deviation)\r\n- [variance](#variance)\r\n- [aggregate](#aggregate)\r\n\r\n####transformation\r\n- [buffer](#buffer)\r\n- [bezier](#bezier)\r\n- [simplify](#simplify)\r\n- [union](#union)\r\n- [intersect](#intersect)\r\n- [erase](#erase)\r\n\r\n####misc\r\n- [flip](#flip)\r\n- [explode](#explode)\r\n- [combine](#combine)\r\n\r\n**Planned Features**\r\n\r\nAdditional feature requests welcomed and encouraged. To request a feature, please add a [github issue](https://github.com/morganherlocker/turf/issues) with a description.\r\n\r\n- concave\r\n- clockwise\r\n- krige\r\n- cluster\r\n- interval\r\n- cluster\r\n- interpolate\r\n- area\r\n- smooth\r\n\r\n- - -\r\n\r\n##Examples:\r\n\r\n###load\r\n\r\nLoads a Feature or FeaturCollection from a file.\r\n\r\n```javascript\r\nvar t = require('turf')\r\ngeojsonFile = '/path/to/file/tress.geojson'\r\n\r\nt.load(geoJsonFile, function(err, trees){\r\n  if(err) throw err\r\n  console.log(trees)\r\n})\r\n```\r\n\r\n\r\n###save\r\n\r\nSaves out a feature or feature collection. 'geojson' and 'topojson' are currently supported.\r\n\r\n```javascript\r\nvar path = './testOut/poly.geojson'\r\nvar poly = t.polygon([[[0,0], [1,0], [1,1],[0,1]]])\r\nvar type = 'geojson'\r\nt.save(path, poly, type, function(err, res){\r\n  if(err) throw err\r\n  console.log(res) // 1\r\n  done()\r\n})\r\n```\r\n\r\n\r\n###point\r\n\r\nCreates a geojson point Feature based on an x and a y coordinate. Properties can be added optionally.\r\n\r\n```javascript\r\nvar t = require('turf')\r\n\r\nvar point1 = t.point(-75.343, 39.984)\r\nvar point2 = t.point(-75.343, 39.984, {name: 'point 1', population: 5000})\r\nconsole.log(point1)\r\nconsole.log(point2)\r\n```\r\n\r\n\r\n###linestring\r\n\r\nCreates a geojson linestring Feature based on a coordinate array. Properties can be added optionally.\r\n\r\n```javascript\r\nvar t = require('turf')\r\n\r\nvar linestring1 = t.linestring([[102.0, -10.0], [103.0, 1.0], [104.0, 0.0], [130.0, 4.0]])\r\nvar linestring2 = t.linestring([[102.0, -10.0], [103.0, 1.0], [104.0, 0.0], [130.0, 4.0]], \r\n  {name: 'line 1', distance: 145})\r\nconsole.log(linestring1)\r\nconsole.log(linestring2)\r\n```\r\n\r\n\r\n###polygon\r\n\r\nCreates a geojson polygon Feature based on a coordinate array. Properties can be added optionally.\r\n\r\n```javascript\r\nvar t = require('turf')\r\n\r\nvar polygon1 = t.point([[[20.0,0.0],[101.0,0.0],[101.0,1.0],[100.0,1.0],[100.0,0.0]]])\r\nvar polygon2 = t.point([[[20.0,0.0],[101.0,0.0],[101.0,1.0],[100.0,1.0],[100.0,0.0]]], \r\n  {name: 'line 1', distance: 145})\r\nconsole.log(polygon1)\r\nconsole.log(polygon2)\r\n```\r\n\r\n\r\n###featurecollection\r\n\r\nCreates a geojson FeatureCollection based on an array of features.\r\n\r\n```javascript\r\nvar t = require('turf')\r\nvar pt1 = t.point(-75.343, 39.984, {name: 'Location A'})\r\nvar pt2 = t.point(-75.833, 39.284, {name: 'Location B'})\r\nvar pt3 = t.point(-75.534, 39.123, {name: 'Location C'})\r\n\r\nvar fc = t.featurecollection([pt1, pt2, pt3])\r\nconsole.log(fc)\r\n```\r\n\r\n\r\n###extent\r\n\r\nCalculates the extent of all features and returns a bounding box.\r\n\r\n```javascript\r\nvar t = require('turf')\r\n\r\nt.load('path/to/file/example.geojson', function(err, features){\r\n  if(err) throw err\r\n  t.extent(features, function(extent){\r\n    console.log(extent) // [minX, minY, maxX, maxY]\r\n  })\r\n})\r\n```\r\n\r\n\r\n###square\r\n\r\nCalculates the minimum square bounding box for another bounding box.\r\n\r\n```javascript\r\nvar t = require('turf')\r\nvar bbox = [0,0,5,10]]\r\n\r\nt.square(bbox, function(err, square){\r\n  if(err) throw err\r\n  console.log(square) // [-2.5, 0, 7.5, 10]\r\n})\r\n```\r\n\r\n\r\n###size\r\n\r\nTakes a bbox and returns a new bbox with a size expanded or contracted by a factor of X.\r\n\r\n```javascript\r\nvar bbox = [0, 0, 10, 10]\r\n\r\nt.size(bbox, 2, function(err, doubled){\r\n  if(err) throw err\r\n  console.log(doubled) // [-10, -10, 20, 20]\r\n})\r\n```\r\n\r\n\r\n###center\r\n\r\nCalculates the absolute center point of all features.\r\n\r\n```javascript\r\nvar t = require('turf')\r\n\r\nt.load('path/to/file/example.geojson', function(layer, err){\r\n  if(err) throw err\r\n  t.center(layer, function(center){\r\n    console.log(center)\r\n  })\r\n})\r\n```\r\n\r\n\r\n###bboxPolygon\r\n\r\nTakes a bbox and returns the equivalent polygon feature.\r\n\r\n```javascript\r\nvar t = require('turf')\r\nvar bbox = [0,0,10,10]\r\n\r\nt.bboxPolygon(bbox, function(err, poly){\r\n  if(err) throw err\r\n  console.log(poly)\r\n})\r\n```\r\n\r\n\r\n###envelope\r\n\r\nTakes a Feature or FeatureCollection and returns a rectangular polygon feature that encompasses all vertices.\r\n\r\n```javascript\r\nvar t = require('turf')\r\nvar pt1 = t.point(-75.343, 39.984, {name: 'Location A'})\r\nvar pt2 = t.point(-75.833, 39.284, {name: 'Location B'})\r\nvar pt3 = t.point(-75.534, 39.123, {name: 'Location C'})\r\nvar fc = t.featurecollection([pt1, pt2, pt3])\r\n\r\nt.envelope(fc, function(err, envelopePoly){\r\n  if(err) throw err\r\n  console.log(envelopePoly)\r\n})\r\n```\r\n\r\n\r\n###centroid\r\n\r\nCalculates the centroid of a polygon Feature or FeatureCollection using the geometric mean of all vertices. This lessons the effect of small islands and artifacts when calculating the centroid of a set of polygons.\r\n\r\n```javascript\r\nvar t = require('turf')\r\nvar poly = t.polygon([[[0,0], [0,10], [10,10] , [10,0]]])\r\n\r\nt.centroid(poly, function(err, centroid){\r\n  if(err) throw err\r\n  console.log(centroid) // a point at 5, 5\r\n})\r\n```\r\n\r\n\r\n###flip\r\n\r\nTakes a point, linestring, polygon, or featurecollection, and flips all of its coordinates from [x, y] to [y, x].\r\n\r\n```javascript\r\nvar t = require('turf')\r\n\r\nvar poly = t.polygon([[[1,0], [1,0], [1,2]], [[.2,.2], [.3,.3],[.1,.2]]])\r\nt.flip(poly, function(err, flipped){\r\n  if(err) throw err\r\n  console.log(flipped)\r\n})\r\n```\r\n\r\n\r\n###explode\r\n\r\nTakes a Feature or FeatureCollection and return all vertices as a collection of points.\r\n\r\n```javascript\r\nvar t = require('turf')\r\nvar poly = t.polygon([[[0,0], [0,10], [10,10] , [10,0]]])\r\n\r\nt.explode(poly, function(err, vertices){\r\n  if(err) throw err\r\n  console.log(vertices)\r\n})\r\n```\r\n\r\n\r\n###combine\r\n\r\nCombines feature collection of point, linestring, or polygon features into multipoint, multilinestring, or multipolygon features.\r\n    \r\n```javascript\r\nvar t = require('turf')\r\nvar pt1 = t.point(50, 1)\r\nvar pt2 = t.point(100, 101)\r\nvar fc = t.featurecollection([pt1, pt2])\r\n\r\nt.combine(fc, function(err, combined){\r\n  if(err) throw err\r\n  console.log(combined)\r\n})\r\n```\r\n\r\n\r\n###remove\r\n\r\nRemoves any features from a feature collection that match a property value.\r\n\r\n```javascript\r\nvar t = require('turf')\r\nvar trees = t.featurecollection([t.point(1,2, {species: 'oak'}), \r\n                                 t.point(2,1, {species: 'dogwood'}), \r\n                                 t.point(3,1, {species: 'maple'})])\r\n\r\nt.remove(points, 'species', 'dogwood', function(err, result) {\r\n  if(err) throw err\r\n  console.log(result)\r\n})\r\n```\r\n\r\n\r\n###filter\r\n\r\nKeeps any features from a feature collection that match a property value.\r\n\r\n```javascript\r\nvar t = require('turf')\r\nvar trees = t.featurecollection([\r\n  t.point(1,2, {species: 'oak'}),\r\n  t.point(2,1, {species: 'birch'}), \r\n  t.point(3,1, {species: 'oak'}),\r\n  t.point(2,2, {species: 'redwood'}), \r\n  t.point(2,3, {species: 'maple'}), \r\n  t.point(4,2, {species: 'oak'})\r\n  ])\r\n\r\nt.filter(trees, 'species', 'oak', function(err, oaks){\r\n  if(err) throw err\r\n  console.log(oaks)\r\n})\r\n```\r\n\r\n\r\n###inside\r\n\r\nChecks to see if a point is inside of a polygon. The polygon can be convex or concave.\r\n\r\n```javascript\r\nvar t = require('turf')\r\nvar poly = t.polygon([[[0,0], [50, 50], [0,100], [100,100], [100,0]]])\r\nvar pt = t.point(75, 75)\r\n\r\nt.inside(pt, poly, function(err, isInside){\r\n  if(err) throw err\r\n  console.log(isInside) // true\r\n})\r\n```\r\n\r\n\r\n###buffer\r\n\r\nBuffers a point, linestring, or polygon feature to a given radius. Units supported are miles, kilometers, and degrees.\r\n\r\n\r\n```javascript\r\nvar t = require('turf')\r\nvar pt = t.point(0, 0.5)\r\nvar unit = 'miles'\r\n\r\nt.buffer(pt, 10, unit, function(err, buffered){\r\n  if(err) throw err\r\n  console.log(buffered)\r\n})\r\n```\r\n\r\n\r\n###distance\r\n\r\nCalculates the distance between two point features in degrees, radians, miles, or kilometers. This uses the haversine formula to account for global curvature.\r\n\r\n```javascript\r\nvar t = require('turf')\r\nvar point1 = t.point(-75.343, 39.984)\r\nvar point2 = t.point(-75.534, 39.123)\r\nvar unit = 'miles' // or 'kilometers', 'degrees', 'radians'\r\n\r\nt.distance(point1, point2, unit, function(err, distance){\r\n  if(err) throw err\r\n  console.log(distance)\r\n})\r\n```\r\n\r\n\r\n###nearest\r\n\r\nReturns the nearest point feature.\r\n\r\n```javascript\r\nvar t = require('turf')    \r\nvar inPoint = t.point(-75.4, 39.4, {name: 'Location A'})\r\n\r\nvar pt1 = t.point(-75.343, 39.984, {name: 'Location B'})\r\nvar pt2 = t.point(-75.833, 39.284, {name: 'Location C'})\r\nvar pt3 = t.point(-75.534, 39.123, {name: 'Location D'})\r\nvar inFeatures = t.featurecollection([pt1, pt2, pt3])\r\n\r\nt.nearest(inPoint, inFeatures, function(err, closestPoint){\r\n  if(err) throw err\r\n  console.log(closestPoint)\r\n})\r\n```\r\n\r\n\r\n###tin\r\n\r\nTakes a set of points and the name of a z-value property and creates a tin (Triangulated Irregular Network). These are often used for developing elevation contour maps or stepped heat visualizations.\r\n\r\n```javascript\r\nvar t = require('turf')\r\nvar z = 'elevation'\r\n\r\nt.load('/path/to/pointsfeatures/elevationPoints.geojson', function(err, points){\r\n  t.tin(points, z, function(err, tin){\r\n    if(err) throw err\r\n    console.log(tin)\r\n  })\r\n})\r\n```\r\n\r\n\r\n###grid\r\n\r\nTakes a bounding box and a cell depth and outputs a feature collection of points in a grid.\r\n\r\n```javascript\r\nvar t = require('turf')\r\nvar depth = 15\r\n\r\nt.grid([0,0,10,10], depth, function(err, grid){\r\n  console.log(grid) // 15x15 grid of points in a FeatureCollection\r\n})\r\n```\r\n\r\n\r\n###planepoint\r\n\r\nTakes a trianglular plane and calculates the z value for a point on the plane.\r\n\r\n```javascript\r\nvar t = require('turf')\r\nvar point = t.point(-75.3221, 39.529)\r\n// triangle is a polygon with \"a\", \"b\", and \"c\" values representing\r\n// the values of the coordinates in order.\r\nvar triangle = t.polygon(\r\n    [[[-75.1221,39.57],[-75.58,39.18],[-75.97,39.86]]], \r\n    {\"a\": 11, \"b\": 122, \"c\": 44}\r\n  )\r\n\r\nt.planepoint(point, triangle, function(err, zValue){\r\n  if(err) throw err\r\n  console.log(zValue)\r\n})\r\n```\r\n\r\n\r\n###midpoint\r\n\r\nTakes two point features and returns the mid point.\r\n\r\n```javascript\r\nvar t = require('turf')\r\nvar pt1 = t.point(0,0)\r\nvar pt2 = t.point(10, 0)\r\n\r\nt.midpoint(pt1, pt2, function(err, midpoint){\r\n  if(err) throw err\r\n  console.log(midpoint)\r\n})\r\n\r\n```\r\n\r\n\r\n###quantile\r\n\r\nTakes a set of features, a property name, and a set of percentiles and outputs a quantile array. This can be passed as a break array to the contour function.\r\n\r\n```javascript\r\nvar t = require('turf')\r\nvar propertyName = 'elevation'\r\nvar percentiles = [10,30,40,60,80,90,99]\r\n\r\nt.load('./testIn/Points3.geojson', function(err, pts){\r\n  if(err) throw err\r\n  t.quantile(pts, propertyName, percentiles, function(err, quantiles){\r\n    if(err) throw err\r\n    console.log(quantiles) // [ 12, 25, 29, 52, 76, 99, 143 ]\r\n  })\r\n})\r\n```\r\n\r\n\r\n###jenks\r\n\r\nTakes a set of features, a property name, and the desired number of breaks and outputs an array of natural breaks. This classification can be used in the contour function or for theming.\r\n\r\n```javascript\r\nvar t = require('turf')\r\nvar propertyName = 'elevation'\r\nvar num = 10\r\n\r\nt.load('./testIn/Points3.geojson', function(err, pts){\r\n  if(err) throw err\r\n  t.jenks(pts, 'elevation', num, function(err, breaks){\r\n    if(err) throw err\r\n    done() // [ 11, 12, 18, 25, 29, 41, 50, 55, 76, 90, 143 ]\r\n  })\r\n})\r\n```\r\n\r\n\r\n###reclass\r\n\r\nTakes a feature collection, a in field, an out field, and an array of translations and outputs an identical feature collection with the out field property populated.\r\n\r\n```javascript\r\nvar t = require('turf')\r\nvar inField = 'elevation',\r\n    outField = 'heightIndex',\r\n    // 0 to 20 will map to 1, 20 to 40 will map to 2, etc.\r\n    translations = [[0, 20, 1], [20, 40, 2], [40, 60 , 3], [60, Infinity, 4]]\r\n\r\nt.load('./testIn/Points3.geojson', function(err, pts){\r\n  if(err) throw err\r\n  t.reclass(pts, inField, outField, translations, function(err, outPts){\r\n    if(err) throw err\r\n    console.log(outPts)\r\n  })\r\n})\r\n```\r\n\r\n\r\n###contour\r\n\r\nTakes a FeatureCollection of points with z values and an array of value breaks and generates contour polygons.  This is a great way to visualize interpolated density on a map.  It is often used for elevation maps, weather maps, and isocrones.  The main advantage over a heat map is that contours allow you to see definitive value boundaries, and the polygons can be used to aggregate data.  For example, you could get the 5000 ft elevation contour of a mountain and the 10000 ft elevation contour, then aggregate the number of trees in each to see how elevation affects tree survival.\r\n\r\n```javascript\r\nvar t = require('turf')\r\nvar z = 'elevation'\r\nvar resolution = 15\r\nvar breaks = [.1, 22, 45, 55, 65, 85,  95, 105, 120, 180]\r\n\r\nt.load('../path/to/points.geojson', function(err, points){\r\n  t.contour(points, z, resolution, breaks, function(err, contours){\r\n    if(err) throw err\r\n    console.log(contours)\r\n  })\r\n})\r\n```\r\n\r\n\r\n###sample\r\n\r\nTakes a feature collection and returns N random features as a feature collection.\r\n\r\n```javascript\r\nvar t = require('turf')\r\nvar num = 10\r\n\r\nt.load('./testIn/Points3.geojson', function(err, pts){\r\n  if(err) throw err\r\n  t.sample(pts, num, function(err, outPts){\r\n    if(err) throw err\r\n    console.log(outPts)\r\n  })\r\n})\r\n```\r\n\r\n\r\n###tag\r\n\r\nPerforms a spatial join on a set of points from a set of polygons.\r\n\r\n```javascript\r\nvar t = require('turf')\r\n\r\nt.load('./testIn/tagPoints.geojson', function(err, points){\r\n  t.load('./testIn/tagPolygons.geojson', function(err, polygons){\r\n    t.tag(points, polygons, 'polyID', 'containingPolyID', function(err, taggedPoints){\r\n      console.log(taggedPoints)\r\n    })\r\n  })\r\n})\r\n```\r\n\r\n\r\n###bezier\r\n\r\nTakes a linestring and outputs a curved version of the line.\r\n\r\n```javascript\r\nvar t = require('turf')\r\nvar resolution = 5000\r\nvar intensity = .85\r\nvar lineIn = t.linestring([\r\n      [\r\n        -80.08724212646484,\r\n        32.77428536643231\r\n      ],\r\n      [\r\n        -80.03746032714844,\r\n        32.84007757059952\r\n      ],\r\n      [\r\n        -80.01548767089844,\r\n        32.74512501406368\r\n      ],\r\n      [\r\n        -79.95368957519531,\r\n        32.850461360442424\r\n      ]\r\n    ])\r\n\r\nt.bezier(lineIn, 5000, .85, function(err, lineOut){\r\n  if(err) throw err\r\n  console.log(lineOut)\r\n})\r\n```\r\n\r\n\r\n###simplify\r\n\r\nTakes a feature collection of polygons or linestrings and returns a simplified version, preserving topology of shared boundaries.\r\n\r\n```javascript\r\nvar t = require('turf')\r\nvar quantization = 50\r\nvar minimumArea = 0\r\n\r\nt.load('./path/to/complex.geojson', function(err, polys){\r\n  t.simplify(polys, quantization, minimumArea, function(err, simplified){\r\n    if(err) throw err\r\n    console.log(simplified)\r\n  })\r\n})\r\n```\r\n\r\n\r\n###average\r\n\r\nCalculates the average value of a field for points within a set of polygons.\r\n\r\n```javascript\r\nvar t = require('turf')\r\n\r\nvar poly1 = t.polygon([[[0,0],[10,0],[10,10], [0,10]]])\r\nvar poly2 = t.polygon([[[10,0],[20,10],[20,20], [20,0]]])\r\nvar polyFC = t.featurecollection([poly1, poly2])\r\nvar pt1 = t.point(5,5, {population: 200})\r\nvar pt2 = t.point(1,3, {population: 600})\r\nvar pt3 = t.point(14,2, {population: 100})\r\nvar pt4 = t.point(13,1, {population: 200})\r\nvar pt5 = t.point(19,7, {population: 300})\r\nvar ptFC = t.featurecollection([pt1, pt2, pt3, pt4, pt5])\r\n\r\nt.average(polyFC, ptFC, 'population', 'pop_avg', function(err, averaged){\r\n  if(err) throw err\r\n\r\n  console.log(averaged.features[0].properties.pop_avg) // 400\r\n  console.log(averaged.features[1].properties.pop_avg) // 200\r\n})\r\n```\r\n\r\n\r\n###median\r\n\r\nCalculates the median value of a field for points within a set of polygons.\r\n\r\n```javascript\r\nvar t = require('turf')\r\n\r\nvar poly1 = t.polygon([[[0,0],[10,0],[10,10], [0,10]]])\r\nvar poly2 = t.polygon([[[10,0],[20,10],[20,20], [20,0]]])\r\nvar polyFC = t.featurecollection([poly1, poly2])\r\nvar pt1 = t.point(5,5, {population: 200})\r\nvar pt2 = t.point(1,3, {population: 600})\r\nvar pt3 = t.point(14,2, {population: 100})\r\nvar pt4 = t.point(13,1, {population: 200})\r\nvar pt5 = t.point(19,7, {population: 300})\r\nvar ptFC = t.featurecollection([pt1, pt2, pt3, pt4, pt5])\r\n\r\nt.median(polyFC, ptFC, 'population', 'pop_median', function(err, medianed){\r\n  if(err) throw err\r\n\r\n  console.log(medianed.features[0].properties.pop_median) // 400\r\n  console.log(medianed.features[1].properties.pop_median) // 200\r\n})\r\n```\r\n\r\n\r\n###sum\r\n\r\nCalculates the sum value of a field for points within a set of polygons.\r\n\r\n```javascript\r\nvar t = require('turf')\r\n\r\nvar poly1 = t.polygon([[[0,0],[10,0],[10,10], [0,10]]])\r\nvar poly2 = t.polygon([[[10,0],[20,10],[20,20], [20,0]]])\r\nvar polyFC = t.featurecollection([poly1, poly2])\r\nvar pt1 = t.point(1,1, {population: 500})\r\nvar pt2 = t.point(1,3, {population: 400})\r\nvar pt3 = t.point(14,2, {population: 600})\r\nvar pt4 = t.point(13,1, {population: 500})\r\nvar pt5 = t.point(19,7, {population: 200})\r\nvar ptFC = t.featurecollection([pt1, pt2, pt3, pt4, pt5])\r\n\r\nt.sum(polyFC, ptFC, 'population', 'pop_sum', function(err, summed){\r\n  if(err) throw err\r\n\r\n  console.log(summed.features[0].properties.pop_sum) // 900\r\n  console.log(summed.features[1].properties.pop_sum) // 1300\r\n})\r\n```\r\n\r\n\r\n###min\r\n\r\nCalculates the min value of a field for points within a set of polygons.\r\n\r\n```javascript\r\nvar t = require('turf')\r\n\r\nvar poly1 = t.polygon([[[0,0],[10,0],[10,10], [0,10]]])\r\nvar poly2 = t.polygon([[[10,0],[20,10],[20,20], [20,0]]])\r\nvar polyFC = t.featurecollection([poly1, poly2])\r\nvar pt1 = t.point(1,1, {population: 500})\r\nvar pt2 = t.point(1,3, {population: 400})\r\nvar pt3 = t.point(14,2, {population: 600})\r\nvar pt4 = t.point(13,1, {population: 500})\r\nvar pt5 = t.point(19,7, {population: 200})\r\nvar ptFC = t.featurecollection([pt1, pt2, pt3, pt4, pt5])\r\n\r\nt.min(polyFC, ptFC, 'population', 'pop_min', function(err, minPolys){\r\n  if(err) throw err\r\n\r\n  console.log(minPolys.features[0].properties.pop_min) // 400\r\n  console.log(minPolys.features[1].properties.pop_min) // 200\r\n})\r\n```\r\n\r\n\r\n###max\r\n\r\nCalculates the min value of a field for points within a set of polygons.\r\n\r\n```javascript\r\nvar t = require('turf')\r\n\r\nvar poly1 = t.polygon([[[0,0],[10,0],[10,10], [0,10]]])\r\nvar poly2 = t.polygon([[[10,0],[20,10],[20,20], [20,0]]])\r\nvar polyFC = t.featurecollection([poly1, poly2])\r\nvar pt1 = t.point(1,1, {population: 500})\r\nvar pt2 = t.point(1,3, {population: 400})\r\nvar pt3 = t.point(14,2, {population: 600})\r\nvar pt4 = t.point(13,1, {population: 500})\r\nvar pt5 = t.point(19,7, {population: 200})\r\nvar ptFC = t.featurecollection([pt1, pt2, pt3, pt4, pt5])\r\n\r\nt.max(polyFC, ptFC, 'population', 'pop_max', function(err, maxPolys){\r\n  if(err) throw err\r\n\r\n  console.log(maxPolys.features[0].properties.pop_max) // 500\r\n  console.log(maxPolys.features[1].properties.pop_max) // 600\r\n})\r\n```\r\n\r\n\r\n###count\r\n\r\nCalculates the count of points within a set of polygons.\r\n\r\n```javascript\r\nvar t = require('turf')\r\n\r\nvar poly1 = t.polygon([[[0,0],[10,0],[10,10], [0,10]]])\r\nvar poly2 = t.polygon([[[10,0],[20,10],[20,20], [20,0]]])\r\nvar polyFC = t.featurecollection([poly1, poly2])\r\nvar pt1 = t.point(1,1, {population: 500})\r\nvar pt2 = t.point(1,3, {population: 400})\r\nvar pt3 = t.point(14,2, {population: 600})\r\nvar pt4 = t.point(13,1, {population: 500})\r\nvar pt5 = t.point(19,7, {population: 200})\r\nvar ptFC = t.featurecollection([pt1, pt2, pt3, pt4, pt5])\r\n\r\nt.count(polyFC, ptFC, 'population', 'point_count', function(err, counted){\r\n  if(err) throw err\r\n\r\n  console.log(counted.features[0].properties.point_count) // 2\r\n  console.log(counted.features[1].properties.point_count) // 3\r\n})\r\n```\r\n\r\n\r\n###deviation\r\n\r\nCalculates the standard deviation value of a field for points within a set of polygons.\r\n\r\n```javascript\r\nvar t = require('turf')\r\n\r\nvar poly1 = t.polygon([[[0,0],[10,0],[10,10], [0,10]]])\r\nvar poly2 = t.polygon([[[10,0],[20,10],[20,20], [20,0]]])\r\nvar polyFC = t.featurecollection([poly1, poly2])\r\nvar pt1 = t.point(1,1, {population: 500})\r\nvar pt2 = t.point(1,3, {population: 400})\r\nvar pt3 = t.point(14,2, {population: 600})\r\nvar pt4 = t.point(13,1, {population: 500})\r\nvar pt5 = t.point(19,7, {population: 200})\r\nvar ptFC = t.featurecollection([pt1, pt2, pt3, pt4, pt5])\r\n\r\nt.deviation(polyFC, ptFC, 'population', 'pop_deviation', function(err, deviated){\r\n  if(err) throw err\r\n\r\n  console.log(deviated.features[0].properties.pop_deviation)\r\n  console.log(deviated.features[1].properties.pop_deviation)\r\n})\r\n```\r\n\r\n\r\n###variance\r\n\r\nCalculates the standard deviation value of a field for points within a set of polygons.\r\n\r\n```javascript\r\nvar t = require('turf')\r\n\r\nvar poly1 = t.polygon([[[0,0],[10,0],[10,10], [0,10]]])\r\nvar poly2 = t.polygon([[[10,0],[20,10],[20,20], [20,0]]])\r\nvar polyFC = t.featurecollection([poly1, poly2])\r\nvar pt1 = t.point(1,1, {population: 500})\r\nvar pt2 = t.point(1,3, {population: 400})\r\nvar pt3 = t.point(14,2, {population: 600})\r\nvar pt4 = t.point(13,1, {population: 500})\r\nvar pt5 = t.point(19,7, {population: 200})\r\nvar ptFC = t.featurecollection([pt1, pt2, pt3, pt4, pt5])\r\n\r\nt.variance(polyFC, ptFC, 'population', 'pop_variance', function(err, varianced){\r\n  if(err) throw err\r\n\r\n  console.log(varianced.features[0].properties.pop_variance)\r\n  console.log(varianced.features[1].properties.pop_variance)\r\n})\r\n```\r\n\r\n\r\n###aggregate\r\n\r\nTakes a set of polygons, a set of points, and an array of aggregations, then perform them. Sum, average, count, min, max, and deviation are  supported.\r\n\r\n```javascript\r\nvar t = require('turf')\r\n\r\nvar poly1 = t.polygon([[[0,0],[10,0],[10,10],[0,10]]])\r\nvar poly2 = t.polygon([[[10,0],[20,10],[20,20], [20,0]]])\r\nvar polyFC = t.featurecollection([poly1, poly2])\r\nvar pt1 = t.point(5,5, {population: 200})\r\nvar pt2 = t.point(1,3, {population: 600})\r\nvar pt3 = t.point(14,2, {population: 100})\r\nvar pt4 = t.point(13,1, {population: 200})\r\nvar pt5 = t.point(19,7, {population: 300})\r\nvar ptFC = t.featurecollection([pt1, pt2, pt3, pt4, pt5])\r\nvar aggregations = [\r\n  {\r\n    aggregation: 'sum',\r\n    inField: 'population',\r\n    outField: 'pop_sum'\r\n  },\r\n  {\r\n    aggregation: 'average',\r\n    inField: 'population',\r\n    outField: 'pop_avg'\r\n  },\r\n  {\r\n    aggregation: 'median',\r\n    inField: 'population',\r\n    outField: 'pop_median'\r\n  },\r\n  {\r\n    aggregation: 'min',\r\n    inField: 'population',\r\n    outField: 'pop_min'\r\n  },\r\n  {\r\n    aggregation: 'max',\r\n    inField: 'population',\r\n    outField: 'pop_max'\r\n  },\r\n  {\r\n    aggregation: 'deviation',\r\n    inField: 'population',\r\n    outField: 'pop_deviation'\r\n  },\r\n  {\r\n    aggregation: 'variance',\r\n    inField: 'population',\r\n    outField: 'pop_variance'\r\n  },\r\n  {\r\n    aggregation: 'count',\r\n    inField: '',\r\n    outField: 'point_count'\r\n  }\r\n]\r\n\r\nt.aggregate(polyFC, ptFC, aggregations, function(err, polys){\r\n  if(err) throw err\r\n  console.log(polys)\r\n})\r\n```\r\n\r\n\r\n###union\r\n\r\nCalculates the union of two polygon features or feature collections.\r\n\r\n```javascript\r\nvar t = require('turf')\r\n\r\nt.load(__dirname + '/testIn/Intersect1.geojson', function(err, polys1){\r\n  t.load(__dirname + '/testIn/Intersect2.geojson', function(err, polys2){\r\n    t.union(polys1, polys2, function(err, unioned){\r\n      if(err) throw err\r\n      console.log(unioned)\r\n    })\r\n  })\r\n})\r\n```\r\n\r\n\r\n###intersect\r\n\r\nCalculates the intersection of two polygon features or feature collections.\r\n\r\n```javascript\r\nvar t = require('turf')\r\n\r\nt.load(__dirname + '/testIn/Intersect1.geojson', function(err, polys1){\r\n  t.load(__dirname + '/testIn/Intersect2.geojson', function(err, polys2){\r\n    t.intersect(polys1, polys2, function(err, intersected){\r\n      if(err) throw err\r\n      console.log(intersected)\r\n    })\r\n  })\r\n})\r\n```\r\n\r\n\r\n###erase\r\n\r\nCalculates polygon 1 minus polygon 2.\r\n\r\n```javascript\r\nvar t = require('turf')\r\n\r\nt.load(__dirname + '/testIn/Intersect1.geojson', function(err, polys1){\r\n  t.load(__dirname + '/testIn/Intersect2.geojson', function(err, polys2){\r\n    t.erase(polys1, polys2, function(err, erased){\r\n      if(err) throw err\r\n      console.log(erased)\r\n    })\r\n  })\r\n})\r\n```\r\n\r\n\r\n- - -\r\n\r\n\r\nThis library is built and maintained by [@morganherlocker](https://twitter.com/morganherlocker) :)\r\n","google":"UA-44771764-1","note":"Don't delete this file! It's used internally to help with page regeneration."}